---
layout: mypost
title: 垃圾回收基础
categories: [Others]
---
# 垃圾回收基础

## 基本概念

### 1. 对象

对象表示的是“通过应用程序利用的数据的集合”。对象配置在内存空间里。GC根据情况将配置好的对象进行移动或销毁操作。因此, 对象是GC的基本单位。一般而言, 对象由头(header)和域(field)构成。

#### 头(header)

我们将对象中保存对象本身信息的部分称为“头”。头主要含有以下信息。

- 对象的大小
- 对象的种类

如果不清楚对象的大小和种类, 就会发生问题, 例如无法判别内存中存储的对象的边界。因此头对GC来说非常重要。此外, 头中事先存有运行GC所需的信息。然而根据GC算法的不同, 信息也不同。

#### 域(field)

我们把对象使用者在对象中可访问的部分称为“域”。可以将其想像成C语言中结构体的成员。对象使用者会引用或替换对象的域值。另一方面, 对象使用者基本上无法直接更改头的信息。

域中的数据类型大致分为以下2种。

- 指针: 指针是指向内存空间中某块区域的值。
- 非指针: 非指针指的是在编程中直接使用值本身。数值、字符以及真假值都是非指针。

在对象内部, 头之后存在1个及1个以上的域。

### 2. 指针

通过GC, 对象会被销毁或保留。这时候起到关健作用的就是指针。因为GC是根据对象的指针指向取搜索其他对象的。另一方面GC对非指针不进行任何操作。

*注意:*

1. 要注意语言处理程序是否能判别指针和非指针。
2. 要注意指针指向对象的哪个部分。指针如果指向对象首地址以外的部分, GC就会变的非常复杂。在大多数语言处理程序中, 指针都默认指向对象的首地址。因为存在这个制约条件, 不仅是GC, 就连语言处理程序的其他各种处理都变得简单了。

### 3. mutator

mutator是Edsger Dijkstra琢磨出来的词, 有“改变某物”的意思。说到要改变什么, 那么就是GC对象间的引用关系。它的实体就是“应用程序”。

mutator实际进行的操作有以下2种: 

1. 生成对象
2. 更新指针

mutator在进行这些操作时, 会同时为应用程序的用户进行一些处理。随着这些处理的逐步推进, 对象间的引用关系也会“改变”。伴随这些变化会产生垃圾, 而负责回收这些垃圾的机制就是GC。

### 4. 堆

堆指的是用于动态(也就是执行程序时)存放对象的内存空间。当mutator申请存放对象时, 所需的内存空间就回从这个堆中被分配给mutator。

GC是管理堆中已分配对象的机制。在开始执行mutator前, GC要分配用于堆的内存空间。一旦开始执行mutator, 程序就会按照mutator的要求在堆中存放对象。等到堆被对象占满后, GC就回启动, 从而分配可用空间。如果不能分配足够的可用空间, 一般情况下我们就要扩大堆。

### 5. 活动对象/非活动对象

我们将分配到内存空间中的对象中哪些能通过mutator引用的对象称为活动对象。反过来, 把分配到堆中哪些不能通过程序引用的对象称为“非活动对象”。也就是说, 不能通过程序引用的对象已经没有人搭理了, 所以死掉了。死掉的对象(即非活动对象)我们就称为“垃圾”。

值的注意的是: 死了的对象不可能活过来。因为就算mutator想要重新引用已经死掉的对象, 我们也没法通过mutator找到它了。

GC会保留活动对象, 销毁非活动对象。当销毁非活动对象时, 其原本占据的内存空间就会得到解放, 供下一个要分配的新对象使用。

### 6. 分配

分配(allocation)指的是在内存空间中分配对象。当mutator需要新对象时, 就会向分配器(allocator)申请一个大小合适的空间。分配器则在堆的可用空间中找寻满足要求的空间, 返回给mutator。

当堆被所有活动对象占满时, 就算运行GC也无法分配可用空间。这时候我们有以下两种选择: 

1. 销毁至今为止的所有计算结果, 输出错误信息。
2. 扩大堆, 分配可用空间。

### 7. 分块

分块(chunk)在GC的世界里指的是为利用对象而事先准备出来的空间。

初始状态下, 堆被一个大的分块所占据。

然后, 程序会根据mutator的要求把这个分块分割成合适的大小, 作为(活动)对象使用。活动对象不久后会转化为垃圾被回收。此时, 这部分被回收的内存空间再次成为分块, 为下次被利用做准备。也就是说, 内存里的各个区块都重复着分块->活动对象->垃圾(非活动对象)->分块->……这样的过程。

### 8. 根

根(root)在GC的世界里, 指的是指向对象的指针的“起点”部分。

### 9. 评价标准

评价GC算法的性能时, 我们采用以下4个标准

- 吞吐量
- 最大暂停时间
- 堆使用效率
- 访问的局部性

#### 吞吐量

一般意义上来讲, 吞吐量(throughput)指的是“在单位时间内的处理能力”, 这点在GC的世界中也不例外。

在mutator整个执行过程中, GC花费的总时长如果是T, 那么吞吐量可以表示为HEAP_SIZE/T。

当然, 人们通常都喜欢吞吐量高的GC算法。然而判断各算法吞吐量的好坏时不能一概而论。即使是同一GC算法, 其吞吐量也是受mutator的动作左右的。评价GC算法的吞吐量时, 有必要把mutator的动作也考虑在内。

#### 最大暂停时间

最大暂停时间指的是“因执行GC而暂停执行mutator的最长时间”。然而不管尝试哪种GC算法, 我们都会发现较大的吞吐量和较短的最大暂停时间不可兼得, 所以应根据执行的应用所重视的指标的不同, 来分别采用不同的GC算法。

#### 堆使用效率

根据GC算法的差异, 堆使用效率也大相径庭。左右堆使用效率的因素有两个。

1. 头的大小: 在堆中堆放的信息越多, GC的效率也就越高, 吞吐量也就随之得到改善。单毋庸置疑, 头越小越好。因此未了执行GC, 需要把在头中存放的信息控制在最小限度。
2. 堆的用法: 举个例子, GC复制算法中, 将堆二等分, 每次只使用一半, 交替进行, 因此总是只能利用堆的一半。相对而言, GC标记-清除算法和引用计数法就能利用整个堆。

不过, 堆使用效率和吞吐量, 以及最大暂停时间不可兼得。简单地说: 可用堆越大, GC运行越快；相反, 想要有效地利用有限的堆, GC花费的时间就越长。

#### 访问的局部性

PC上有4种存储器, 分别是寄存器、缓存、内存、辅助存储器。

具有引用关系的对象之间通常很可能存在连续访问的情况。这在多数程序中都很常见, 称为“访问的局部性”。考虑到访问的局部性, 把具有引用关系的对象安排在堆中较近的位置, 就能提高在缓存中读取到想利用的数据的概率, 令mutator高速运行。而有些GC算法会根据引用关系重排对象。

