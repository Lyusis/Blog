---
layout: mypost
title: Shell编程基础
categories: [Shell]
---

# Shell编程基础

## 变量

### 自定义变量

1. 变量是由任何字母、数字、和下划线组成的字符串, 且不能以数字开头.
2. 区分字母大小写, 例如Var1和var1是不同的
3. 变量、等号、值中间不能出现任何空格

```shell
var1=hello
echo $var1
```

### 位置参数变量

1. $n: n为数字, $0代表脚本本身, $1~$9代表第1~9个参数, 10以上的参数需要用大括号表示, 如${10}
2. $@: 代表命令行所有参数, 但是每个参数区别对待
3. $*: 代表命令行所有参数, 所有参数视为一个整体
4. $#: 参数个数

### 环境变量

1. 简介: Linux是一个多租户的操作系统, 针对不同的用户都会有一个专有的运行环境, 不同的专有环境就是一主默认环境变量的组合.
2. 对所有用户生效的环境变量: /etc/profile
3. 对特定用户生效的环境变量: ~/.bashrc 或者 ~/.bash_profile
4. 临时有效的环境变量: 脚本或命令行使用export
5. 常用环境变量

| 环境变量   | 含义                       |
| :--------- | :------------------------- |
| `PATH`     | 命令搜索的路径             |
| `HOME`     | 用户家目录的路径           |
| `LOGNAME`  | 用户登录名                 |
| `PWD`      | 当前所在路径               |
| `HISTFILE` | 历史命令的保存文件         |
| `HISTSIZE` | 历史命令保存的最大行数     |
| `HOSTNAME` | 主机名                     |
| `SHELL`    | 用户当前使用的SHELL        |
| `PS1`      | 一级命令提示符             |
| `TMOUT`    | 用户和系统交互过程的超时值 |
| `IFS`      | 系统输入分隔符             |
| `OFS`      | 系统输出分割符             |

### 管道

`|`符号即为管道, 意为将前一个命令的结果传递给后续命令, 可以连续传递

从某种意义上来说, 是重定向的一种实现

### 退出状态码

1. 所有的shell命令都是使用退出状态码来告知shell它已执行完毕
2. 退出状态码是一个0~255的整数值
3. Linux提供了一个`$?`来捕获退出状态码的值, 重点在于: 0代表命令执行成功, 非0代表命令执行失败

| 状态码 | 含义                       |
| ------ | -------------------------- |
| 0      | 命令成功结束               |
| 1      | 一般性未知错误             |
| 2      | 不适合的shell命令          |
| 126    | 命令不可执行               |
| 127    | 没找到命令                 |
| 128    | 无效的退出参数             |
| 128+x  | 与Linux信号x相关的严重错误 |
| 130    | 通过Ctrl+C终止的命令       |
| 255    | 正常范围之外的退出码       |

```shell
cat $description/$time-$1.md | while read line; 
    do
        if [ -z $line ]; then 
            break
        else
            echo "已存在文件, 请确认"
            exit 1
        fi
    done
# 以上的代码并不会因为exit 1 而直接退出, 因为包裹在了while语句中, 相当于一个子shell
# 如果需要确实地退出, 需要在外部再做一次判断
if [ $? -eq 1 ]; then
    exit 1
fi
```

### 变量替换

| 语法                           | 说明                                                    |
| ------------------------------ | ------------------------------------------------------- |
| `${变量名#匹配规则}`           | 从变量开头进行规则匹配, 将符合最短的数据删除            |
| `${变量名##匹配规则}`          | 从变量开头进行规则匹配, 将符合最长的数据删除            |
| `${变量名%匹配规则}`           | 从变量尾部进行规则匹配, 将符合最短的数据删除            |
| `${变量名%%匹配规则}`          | 从变量尾部进行规则匹配, 将符合最长的数据删除            |
| `${变量名/旧字符串/新字符串}`  | 变量内容符合旧字符串, 则第一个旧字符串会被新字符串取代  |
| `${变量名//旧字符串/新字符串}` | 变量内容符合旧字符串,, 则全部的旧字符串会被新字符串取代 |

### 变量测试

**配置:** 变量声明

| 变量配置方式       | str没有配置 | str为空字符串 | str已配置且非空 |
| ------------------ | ----------- | ------------- | --------------- |
| `var=${str-expr}`  | var=expr    | var=          | var=$str        |
| `var=${str:-expr}` | var=expr    | var=expr      | var=$str        |
| `var=${str+expr}`  | var=        | var=expr      | var=expr        |
| `var=${str:+expr}` | var=        | var=          | var=expr        |
| `var=${str=expr}`  | var=expr    | var=          | var=$str        |
| `var={str:=expr}`  | var=expr    | var=expr      | var=$str        |

### 字符串处理

#### 计算字符串长度

1. 方法一: `${#string}`
2. 方法二: `expr length "$string"`, string有空格, 则必须加双引号

#### 获取子串信息

1. 抓取子串第一个字符数字串出现的位置: `expr index $string $substring`

2. 计算子串长度, 必须从头开始匹配: `expr match $string substr`

3. 抽取子串(`$`符号命令下标从0开始, `expr`命令下标从1开始)

   | 语法                                    | 说明                             |
   | --------------------------------------- | -------------------------------- |
   | `${string:position}`                    | 从string中的position开始         |
   | `${string:position:length}`             | 从position开始, 匹配长度为length |
   | `${string: -position}`                  | 从右边开始匹配                   |
   | `${string: (position)}`                 | 从左边开始匹配                   |
   | `expr substr $string $position $length` | 从position开始, 匹配长度为length |

### 命令替换

1. 在脚本的变量位置中执行复杂命令
2. 方法一:  `````command` ````
3. 方法二:  `$(command)`

### 读取输入

1. `read -? var`命令可以读取输入值, 并储存在var中
2. `-?`:
   1. -d :  表示delimiter, 即定界符, 一般情况下是以IFS为参数的间隔, 但是通过-d, 我们可以定义一直读到出现执行的字符位置.例如read –d madfds value, 读到有m的字符的时候就不在继续向后读, 例如输入为 hello m, 有效值为"hello”, 请注意m前面的空格等会被删除.这种方式可以输入多个字符串, 例如定义".”作为结符号等等
   2. -e : 只用于互相交互的脚本, 它将readline用于收集输入行.读到这几句话不太明白什么意思, 先跳过.
   3. -n :  用于限定最多可以有多少字符可以作为有效读入.
   4. -p : 用于给出提示符, `read –p '… my promt?' value`
   5. -r : 在参数输入中, 我们可以使用`/`表示没有输入完, 换行继续输入, 如果我们需要行最后的’/’作为有效的字符, 可以通过-r来进行. 此外在输入字符中, 我们希望/n这类特殊字符生效, 也应采用-r选项.
   6. -s :  对于一些特殊的符号, 例如箭头号, 不将他们在terminal上打印, 例如read –s key, 我们按光标, 在回车之后, 如果我们要求显示, 即echo, 光标向上, 如果不使用-s, 在输入的时候, 输入处显示^[[A, 即在terminal上 打印, 之后如果要求echo, 光标会上移.
   7. -t : 用于表示等待输入的时间, 单位为秒, 等待时间超过, 将继续执行后面的脚本, 注意不作为null输入, 参数将保留原有的值.

### 有类型变量

declare命令和typeset命令, 两者等价, 都是用来定义变量类型的

**declare命令参数表**

| 参数 | 含义                               |
| ---- | ---------------------------------- |
| -r   | 将变量设为只读                     |
| -i   | 将变量设为整数                     |
| -a   | 将变量定义为数组                   |
| -f   | 显示此脚本前定义过的所有函数及内容 |
| -F   | 仅显示此脚本前定义过的函数名       |
| -x   | 将变量声明为环境变量               |

### 数组

1. 使用`@`或`*`可以获取数组中的所有元素, `${array[@]}`

2. `${#array[@]}`可以获取数组的长度

3. `unset array[i]`删除元素 `unset array`清空数组

4. `${array[@]:a:b}`显示数组数组下标索引从a开始到b的元素, 不包括b

5. `${array[@]/an/An}`将数组中所有包含an的子串替换为AN

6. 数组遍历

   ```shell
   for v in ${array[@]}
   do 
   	echo $v
   done
   ```

## 数学运算

### 双括号 `(())`

使用双括号可以进行算数运算, 可以写类C语言的运算表达式

可用运算符: `value++` `value--` `++value` `--value` `!` `==` `>` `<` `>=` `<=` `&&` `||`

**注意事项**: 

1. 双括号结构中, 变量名引用可以加$, 也可以不加  
2. 运算符前后可以有空格, 也可以没有  
3. 可以用于if、for、while等循环控制结构中  
4. 多个运算符使用逗号分`((a = a + 1, b = b -1))`  
5. 不支持浮点型  

### 双方括号 `[[]]`

支持正则表达式, 可以使用`=~`来检测字符串是否符合某个正则表达式

用法为: `[[ str =~ regex ]]`其中, str 表示字符串, regex 表示正则表达式

**注意事项**

1. 比较数字需要使用 -eq、-gt 等选项, 推荐使用`(())`进行整数值计算  
2. 双方括号结构中, 变量名引用必须加$  
3. `[[`后面必须要空格, `]]`前面也必须要空格  

### expr

1. 语法: `expr $num1 operator $num2`

2. 操作符对照表

   | 操作符                     | 含义                                     |
   | -------------------------- | ---------------------------------------- |
   | `num1 | num2`              | num1不为空且非0, 返回num1; 否则返回num2  |
   | `num1 & num2`              | num1不为空且非0, 返回num1; 否则返回0     |
   | `num1 < <= = != > >= num2` | num1 operator num2, 符合返回1; 否则返回0 |
   | `num1 + - * / % num2`      | 普通数值运算                             |

   **注:** 大多数时候需要`\`进行转义, 只能精确到整数, 对浮点数进行计算会报错

   ### bc

   1. bc是bash内建的运算器, 支持浮点运算，内建变量scale可以设置小数位, 默认为0.   bc可以识别（浮点）数字，变量，表达式，编程语句，函数。

   2. 可以使用bc命令从shell提示符访问bc，quit退出bc: 

      ```shell
      # bc
      bc 1.06.95
      Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.
      This is free software with ABSOLUTELY NO WARRANTY.
      For details type `warranty'. 
      1.25*3
      3.75
      quit
      ```

   3. 在脚本中的用法

      ```shell
      #!/bin/bash
      # 使用``包裹
      var=`bc << EOF
      scale=4
      a=5
      b=4
      b/a
      EOF`
      echo $var
      
      # 使用echo和管道符
      var1 = `echo "scale=4;$num1/$num2" | bc`
      echo $var
      ```

      

## 条件语句

### case语句语法

```shell
case $var in
	pattern1)
		commands;
		;;　# 类似于传统的break;
	pattern2)
		commands;
	*) # 相当于default
		commands;
esac
```

### if语句语法

```shell
if command | condition #注意:shell中判断符`==``!=`等的左右两边必须空格
then
	commands
elif command | condition
then
	commands
else
	commands
fi
```

### 数值比较

| 数值比较符  | 含义                                    |
| ----------- | --------------------------------------- |
| `n1 -eq n2` | n1和n2相等, 则返回true, 否则返回false   |
| `n1 -ne n2` | n1和n2不相等, 则返回true, 否则返回false |
| `n1 -gt n2` | n1大于n2, 则返回true, 否则返回false     |
| `n1 -ge n2` | n1大于等于n2, 则返回true, 否则返回false |
| `n1 -lt n2` | n1小于n2, 则返回true, 否则返回false     |
| `n1 -le n2` | n1小于等于n2, 则返回true, 否则返回false |

### 字符串比较

| 字符串比价     | 含义                  |
| -------------- | --------------------- |
| `str1 = str2`  | 想等比较              |
| `str1 != str2` | 不等比较              |
| `str1 < str2`  | str1小于str2为true    |
| `str1 > str2`  | str1大于str2为true    |
| `-n str1`      | str1长度不是0则为true |
| `-z str1`      | str1长度为0则为true   |

### 文件比较

| 文件比较          | 含义                     |
| ----------------- | ------------------------ |
| `-d file`         | file是否为目录           |
| `-f file`         | file是否为文件           |
| `-e file`         | file是否存在             |
| `-r file`         | file是否可读             |
| `-w file`         | file是否可写             |
| `-x file`         | file是否可执行           |
| `-s file`         | file是否存在且非空       |
| `file1 -nt file2` | file1比file2新, 则为true |
| `file1 -ot file2` | file1比file2旧, 则为true |

## 循环语句

### for语句语法

```shell
for var in list
do
	commands
done
```

**小技巧: **

```shell
# 遍历01~20, 2位
for i in {01..20} 
do
	echo "Number is $i"
done

# shell中空格和Tab默认分割, 可以通过IFS进行修改
IFS=":"
list="ZHANGSAN:LISI:WANGWU" 
for i in $list
do
	echo i
done

# 读取命令的结果
FILE=$(ls /opt/)

for i in $FILE
do 
	if [ -d /opt/$i ]; then
		echo "$i is DIR"
	elif [ -f /opt/$i ]; then
		echo "$i is FILE"
	else
		echo "ERROR"
	fi
done
```

#### C语言风格

```shell
for (( i = 1; i <= 100; i++ ))
do
	(( sum+=$i ))
done
echo $sum
```

### while语句语法

```shell
while commond 
do
	commands
done
```

### until语句语法

```shell
until command
do
	commands
done
```

