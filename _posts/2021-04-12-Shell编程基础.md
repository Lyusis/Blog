---
layout: mypost
title: Shell编程基础
categories: [Shell]
---

# Shell编程基础

## 变量

### 自定义变量

1. 变量是由任何字母、数字、和下划线组成的字符串, 且不能以数字开头.
2. 区分字母大小写, 例如Var1和var1是不同的
3. 变量、等号、值中间不能出现任何空格

```shell
var1=hello
echo $var1
```

### 位置参数变量

1. $n: n为数字, $0代表脚本本身, $1~$9代表第1~9个参数, 10以上的参数需要用大括号表示, 如${10}
2. $@: 代表命令行所有参数, 但是每个参数区别对待
3. $*: 代表命令行所有参数, 所有参数视为一个整体
4. $#: 参数个数

### 环境变量

1. 简介: Linux是一个多租户的操作系统, 针对不同的用户都会有一个专有的运行环境, 不同的专有环境就是一主默认环境变量的组合.
2. 对所有用户生效的环境变量: /etc/profile
3. 对特定用户生效的环境变量: ~/.bashrc 或者 ~/.bash_profile
4. 临时有效的环境变量: 脚本或命令行使用export
5. 常用环境变量

| 环境变量 | 含义                       |
| :------- | :------------------------- |
| PATH     | 命令搜索的路径             |
| HOME     | 用户家目录的路径           |
| LOGNAME  | 用户登录名                 |
| PWD      | 当前所在路径               |
| HISTFILE | 历史命令的保存文件         |
| HSTSIZE  | 历史命令保存的最大行数     |
| HOSTNAME | 主机名                     |
| SHELL    | 用户当前使用的SHELL        |
| PS1      | 一级命令提示符             |
| TMOUT    | 用户和系统交互过程的超时值 |
| IFS      | 系统输入分隔符             |
| OFS      | 系统输出分割符             |

### 管道

`|`符号即为管道, 意为将前一个命令的结果传递给后续命令, 可以连续传递

从某种意义上来说, 是重定向的一种实现

### 退出状态码

1. 所有的shell命令都是使用退出状态码来告知shell它已执行完毕
2. 退出状态码是一个0~255的整数值
3. Linux提供了一个`$?`来捕获退出状态码的值, 重点在于: 0代表命令执行成功, 非0代表命令执行失败

| 状态码 | 含义                       |
| ------ | -------------------------- |
| 0      | 命令成功结束               |
| 1      | 一般性未知错误             |
| 2      | 不适合的shell命令          |
| 126    | 命令不可执行               |
| 127    | 没找到命令                 |
| 128    | 无效的退出参数             |
| 128+x  | 与Linux信号x相关的严重错误 |
| 130    | 通过Ctrl+C终止的命令       |
| 255    | 正常范围之外的退出码       |

```shell
cat $description/$time-$1.md | while read line; 
    do
        if [ -z $line ]; then 
            break;
        else
            echo "已存在文件, 请确认"
            exit 1
        fi
    done
# 以上的代码并不会因为exit 1 而直接退出, 因为包裹在了while语句中, 相当于一个子shell
# 如果需要确实地退出, 需要在外部再做一次判断
if [ $? -eq 1 ]; then
    exit 1
fi
```

## 数学运算

### 双括号 `(())`

使用双括号可以进行算数运算, 可以写类C语言的运算表达式

可用运算符: `value++` `value--` `++value` `--value` `!` `==` `>` `<` `>=` `<=` `&&` `||`

**注意事项**: 
	1. 双括号结构中, 变量名引用可以加$, 也可以不加
  	2. 运算符前后可以有空格, 也可以没有
  	3. 可以用于if、for、while等循环控制结构中
  	4. 多个运算符使用逗号分`((a = a + 1, b = b -1))`
  	5. 不支持浮点型

### 双方括号 `[[]]`

支持正则表达式, 可以使用`=~`来检测字符串是否符合某个正则表达式

用法为: `[[ str =~ regex ]]`其中, str 表示字符串, regex 表示正则表达式

**注意事项**

 	1. 比较数字需要使用 -eq、-gt 等选项, 推荐使用`(())`进行整数值计算
 	2. 双方括号结构中, 变量名引用必须加$
 	3. `[[`后面必须要空格, `]]`前面也必须要空格

## 条件语句

### case语句语法

```shell
case $var in
	pattern1)
		commands;
		;; # 相当于break;
	pattern2)
		commands;
	*) # 相当于default
		commands;
esac
```

### if语句语法

```shell
if command | condition #注意:shell中判断符`==``!=`等的左右两边必须空格
then
	commands
elif command | condition
then
	commands
else
	commands
fi
```

### 数值比较

| 数值比较符 | 含义                                    |
| ---------- | --------------------------------------- |
| n1 -eq n2  | n1和n2相等, 则返回true, 否则返回false   |
| n1 -ne n2  | n1和n2不相等, 则返回true, 否则返回false |
| n1 -gt n2  | n1大于n2, 则返回true, 否则返回false     |
| n1 -ge n2  | n1大于等于n2, 则返回true, 否则返回false |
| n1 -lt n2  | n1小于n2, 则返回true, 否则返回false     |
| n1 -le n2  | n1小于等于n2, 则返回true, 否则返回false |

### 字符串比较

| 字符串比价   | 含义                  |
| ------------ | --------------------- |
| str1 = str2  | 想等比较              |
| str1 != str2 | 不等比较              |
| str1 < str2  | str1小于str2为true    |
| str1 > str2  | str1大于str2为true    |
| -n str1      | str1长度不是0则为true |
| -z str1      | str1长度为0则为true   |

### 文件比较

| 文件比较        | 含义                     |
| --------------- | ------------------------ |
| -d file         | file是否为目录           |
| -f file         | file是否为文件           |
| -e file         | file是否存在             |
| -r file         | file是否可读             |
| -w file         | file是否可写             |
| -x file         | file是否可执行           |
| -s file         | file是否存在且非空       |
| file1 -nt file2 | file1比file2新, 则为true |
| file1 -ot file2 | file1比file2旧, 则为true |