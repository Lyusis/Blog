---
layout: mypost
title: 多线程总结
categories: [Multi-Threading]
---
# 多线程总结
## 从单线程到多线程

```java
public class test{
  public static void main(String[] args){
    System.out.println("Hello World");
  }
}
```
## 多线程的实现方法

## 线程安全与性能

## Java内存模型(JMM)

## 线程池

### 线程池的属性

1. corePoolSize: 核心线程数, 线程池在完成初始化以后, 默认没有线程启动, 而接受任务之后会启动线程, 这时启动线程的上限即为corePoolSize
2. maxPoolSize: 最大线程数, 在核心线程数(上限)的基础上, 我们可能还需要进一步扩大线程数, 这时的上限即为该最大线程数, 扩容规则为: 当核心线程数与任务队列都满之后, 会进一步启动线程扩大吞吐量, 直至线程数到达最大线程数.
3. keepAliveTime: 保持存活时间, 指线程不再使用时, 空闲多久后(所指定时间)线程会回收
4. workQueue: 工作队列, BlockingQueue, 存放任务的数量
   1. 直接交接: SynchronousQueue, 只是通过该队列提交, 基本不储存, 注意提高corePoolSize和maxPoolSize
   2. 无界队列: LinkedBlockingQueue, 不会被塞满, maxPoolSize基本就无效了, 容易造成OOM
   3. 有界队列: ArrayBlockingQueue, 有上限
5. threadFactory: 当线程池需要新的线程来处理任务的时候, 会通过调用threadFactory来创建. 默认使用Executors.defaultThreadFactory.
6. Handler: 线程无法接受提交任务时的拒绝策略, 通常为任务队列与最大线程都满的情况.

判断顺序: corePoolSize->workQueue->maxPoolSize

在ThreadPoolExecutor类的参数中，变量名是maximumPoolSize；不过在org.springframework.scheduling.concurrent包的ThreadPoolExecutorFactoryBean类等其他类中，也有使用maxPoolSize作为参数名的情况，我们直接理解为maximumPoolSize和maxPoolSize是相同的就可以了。

线程池的核心线程数一般设置在CPU核心数的1-2倍之间, 而最大线程数则为10倍左右, 更好的确定线程数的方法是通过压力测试确定业务确实需要的线程数. 

### 默认线程池

1. newFixedThreadPool: 固定数量的线程池, 进入的是LinkedBlockingQueue, 无容量上限队列, 所以当请求数越来越多, 并且无法及时处理完毕的时候, 也就是请求堆积的时候会容易造成占用大量的内存, 可能会导致OOM.
2. newSingleThreadExecutor: 单线程线程池. 与newFixedThreadPool的原理基本一致, 只是把线程数设置为1, 所以当请求堆积的时候, 也会占用大量的内存.
3. newCachedThreadPool: 可缓存线程池, 无界线程池(上限是整型最大值), 可能会创建超大量的线程, 以至于导致OOM. Cache指的是对线程的缓存, 如果一段时间线程空闲就回收.
4. newScheduledThreadPool: 支持定时及周期型执行任务. 可以设置initialDelay: 初始化延时, period: 两次开始执行最小间隔时间, unit: 计时单位.

| Parameter     | FixedThreadPool      | CachedThreadPool  | ScheduledThreadPool | SingleThreaded |
| ------------- | -------------------- | ----------------- | ------------------- | -------------- |
| corePoolSize  | constructor-arg      | 0                 | constructor-arg     | 1              |
| maxpoolSize   | same as corePoolSize | Integer.MAX_VALUE | Integer.MAX_VALUE   | 1              |
| keepAliveTime | 0 seconds            | 60 seconds        | 60 seconds          | 0 seconds      |

### 停止线程池

1. shutdown: 初始化关闭线程池的流程, 会拒绝新的任务进入队列, 但是要到所有现存任务完成才会关闭线程池. 可以通过isShutdown判断是否进入Shutdown状态.
2. isTerminated: 用于检测整个线程池是不是完全终止了. awaitTermination: 等待一段时间, 如果在等待时间内线程都执行完毕了就输出true, 没有执行完毕就输出false. 另外被打断后会报InterruptException.
3. shutdownNow: 立刻关闭, 通过interrypted方法关闭线程, 任务队列中的任务则会返回.

### 拒绝策略

1. AbotrPolicy: 抛出异常
2. DiscardPolicy: 静默丢弃
3. DiscardOldestPolicy: 丢弃最旧任务
4. CallerRunsPolicy: 让提交者(主线程)进行执行, 可以降低提交速度

### 添加钩子

可以通过继承ThreadPoolExecutor类, 实现beforeExecute方法, 从而达成钩子的效果.

### Executor家族

1. Executor: 顶层方法, 只有一个execute(Runnable)方法, 用于执行线程
2. ExecutorService: 继承了Executor, 同时增加了一些shutdown之类的方法.
3. Executors: 工具类, 可以用于创建预定义线程池.
4. ThreadPoolExecutor: 支持自定义线程池等操作. 

### 线程池状态

1. RUNNING: 接受新任务并处理排队任务
2. SHUTDOWN: 不接受新任务, 但排队处理任务
3. STOP: 不接受新任务, 也不处理排队任务, 并中断正在进行的任务
4. TIDYING: 所有任务都终止, workerCount为零时, 线程会转换到TIDYING状态, 并将运行terminate()钩子方法.
5. TERMINATED: terminate()运行完成

### 线程池执行注意点

1. 避免任务堆积
2. 避免线程数过度增加
3. 排查线程泄漏, 避免业务编写原因线程无法关闭

## Java多线程工具类

### ThreadLocal

TheadLocal是一个线程内部的储存类, 可以再制定线程内存储数据, 同时也只有制定线程可以得到数据.

#### 适用场景

1. 每个线程需要一个独享的对象(通常是工具类, 例如SimpleDateFormat和Random)

2. 每个线程内需要保存全局变量(例如在拦截器中获取用户信息), 可以让不同方法直接使用, 避免参数传递的麻烦. 

   (注: 也可以用static的ConcurrentHashMap，把当前线程的ID作为key，把user作为value来保存，这样可以做到线程间的隔离，但是依然有性能影响。)

#### 作用

1. 让每个需要用到的对象在线程间隔离(每个线程都有自己的独立的对象)
2. 在任何方法中都可以轻松获取对象

根据共享对象的不同, 选择initialValue(第一次就需要把对象初始化出来)或者set(需要根据实际情况, 根据对象不同再生成不同的内容)

#### 优点

1. 达到线程安全
2. 不需要加锁, 提高执行效率
3. 更高效地利用内存, 节省开销: 相比于每个任务都新建一个SimpleDateFormat, 显然用ThreadLocal可以节省内存和开销
4. 免去传参的繁琐: 无论是工具类, 还是每个用户不同的用户名, 都可以再任何地方直接通过ThreadLocal拿到, 再也不需要每次都传同样的参数. ThreadLocal使得代码耦合度更低, 更优雅.

#### 结构

1. 每个Thread中都有一个ThreadLocalMap成员变量
2. 每个ThreadLocalMap中有多个ThreadLocal对象

#### 重要方法

1. `T initialValue()`: 该方法会返回当前线程对应的"初始值", 这是一个延迟加载的方法, 只有在调用get的时候才会被触发. 当线程第一次使用get方法访问变量时, 将调用此方法, 除非线程先前调用了set方法, 在这种情况下, 不会为线程调用initialValue方法. 通常, 每个线程最多调用一次此方法, 但如果已近调用了remove()后, 再调用get(), 则可以再次调用此方法. 如果不重写本方法, 这个方法会返回null. 一般使用匿名内部类的方法来重写initialValue()方法, 以便在后续使用中可以初始化副本对象.

   ```java
   // lambda表达式写法
   public static ThreadLocal<SimpleDateFormat> dateFormatThreadLocal = ThreadLocal.withInitial(()->new SimpleDateFormat("yyyy-MM-dd hh:ss:ss"));
   
   // 传参数
   class Service1 {
       public void process(String name) {
           User user = new User("NAME");
           UserContextHolder.holder.set(user);
       }
   }
   class UserContextHolder {
       public static ThreadLocal<User> holder = new ThreadLocal<>();
   }
   ```

2. `void set(T t)`: 为线程设置一个新值

3. `T get()`: 得到这个线程对应的ThreadLocalMap, 调用map.getEntry方法, 把ThreadLocal的引用作为参数传入, 取出map中属于本ThreadLocal的value. 如果是首次调用get(), 则会调用initialize来得到这个值. 

4. `void remove()`: 删除对应线程的值

#### 注意点

1. 内存泄漏: 某个对象不再有用, 但是占用的内存却不能被回收. ThreadLocal中, key是基于弱引用实现的, 弱引用的特点是, 如果这个对象只被弱引用关联(没有任何强引用关联), 那么这个对象就可以被回收, 所以弱引用不会阻止GC. 所以主要是强引用的Value会泄漏, 正常情况下, 当线程终止, 保存在ThreadLocal里的value会被垃圾回收, 因为没有任何强引用了. 但是如果线程始终不终止(或者保持时间较久), 那么key对应的value就不能被回收, 因为有以下的调用链: 

   ​	`Thread -> ThreadLocalMap -> Entry(key为null) -> Value`

   因为value和Thread之间还存在这个强引用链路, 所以导致value无法回收, 就可能会出现OOM.

   JDK已近考虑到了这个问题, 所以在set, remove, rehash方法中会扫描key为null的Entry, 并把对应的value设置为null, 这样value对象就可以被回收, 但是如果一个ThreadLocal不被使用, 那么实际上set, remove, rehash方法也不会被调用, 如果同时线程又不停止, 那么调用链就一直存在, 那么就导致了value的内存泄漏. 

2. 如何避免内存泄漏(阿里规约): 调用remove方法, 就会删除对应的Entry对象, 可以避免内存泄漏, 所以使用完ThreadLocal之后, 应该主动调用remove方法.

### Lock锁

#### 为什么需要Lock: synchronize有什么问题

1. 效率低: 锁的释放情况少, 试图获得锁时不能设定超时, 不能中断一个正在试图获得锁的线程.
2. 不够灵活(读写锁更灵活): 加锁和释放的时机单一, 每个锁仅有单一的条件(某个对象), 可能是不够的.
3. 无法知道是否成功获取到锁.

#### 主要方法

1. lock(): 最普通的获取锁, 如果锁已被其他线程获取, 则进行等待. lock不会像synchronized一样在异常时自动释放锁, 因此最佳实践是, 在finally中释放锁, 以抱枕发生异常时, 锁一定被释放.

2. tryLock(): 尝试锁.

   ```java
   Lock lock = new ReentrantLock();
   if (lock.tryLock()) {
     try{
       method();
       // manipulate protected state
     } finally{
       lock.unlock();
     }
   } else {
     //perform alternative actions
   }
   ```

3. tryLock(long time, TimeUnit unit): 超时就放弃.

4. lockInterruptibly(): 相当于tryLock(long time, TimeUnit unit)把超时时间设置为无线, 在等待锁的过程中, 线程可以被中断.

5. unlock(): 解锁

#### 锁的分类

1. 线程要不要锁住同步资源: 
   1. 锁住: 悲观锁: 互斥同步锁: synchronized和Lock相关类
      1. 阻塞和唤醒带来的性能劣势
      2. 永久阻塞: 如果持有锁的线程被永久阻塞, 比如遇到了无限循环, 死锁等活跃性问题, 那么等待该线程释放锁的线程可能永远都得不到执行
      3. 适用于并发写入多的情况, 适合于临界区持锁时间比较长的情况, 悲观锁可以避免大量的无用自旋等消耗. 比如说: 临界区有IO操作, 临界区代码复杂或者循环量大, 临界区竞争非常激烈等.
   2. 不锁住: 乐观锁: 非互斥同步锁: 原子类, 并发容器
      1. CAS算法: 
      2. 适合并发写入少, 大部分是读取的场景, 不加锁的能让读取性能大幅度提高.
2. 多线程能否共享一把锁: 
   1. 可以: 共享锁
   2. 不可以: 独占锁
3. 多线程竞争时是否排队: 
   1. 排队: 公平锁
   2. 先尝试插队, 插队失败再排队: 非公平锁
4. 同一个线程是否可以重复获得同一把锁: 
   1. 可以: 可重入: ReentrantLock: 
   2. 不可以: 不可重入锁
5. 是否可中断: 
   1. 可以: 可中断锁
   2. 不可以: 非可中断锁
6. 等锁的过程: 
   1. 自旋: 自旋锁
   2. 阻塞: 非自旋锁

## CAS

## AQS





