import{_ as s,c as a,o as i,V as e}from"./chunks/framework.pRwbWk_8.js";const y=JSON.parse('{"title":"Redis基础","description":"","frontmatter":{},"headers":[],"relativePath":"Redis基础.md","filePath":"Redis基础.md"}'),n={name:"Redis基础.md"},l=e(`<h1 id="redis基础" tabindex="-1">Redis基础 <a class="header-anchor" href="#redis基础" aria-label="Permalink to &quot;Redis基础&quot;">​</a></h1><h2 id="redis介绍" tabindex="-1">Redis介绍 <a class="header-anchor" href="#redis介绍" aria-label="Permalink to &quot;Redis介绍&quot;">​</a></h2><h3 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h3><ol><li>内存数据库, 速度快, 也支持数据的持久化。</li><li>Redis不仅仅支持简单的key-value类型的数据, 同时还提供Lists、Hashes、Sets、Sorted Sets等多种数据结构的存储。</li><li>Redis支持数据的备份(master-slave) 与集群(分片存储), 以及拥有哨兵监控机制。</li><li>支持事务。</li></ol><h3 id="优势" tabindex="-1">优势 <a class="header-anchor" href="#优势" aria-label="Permalink to &quot;优势&quot;">​</a></h3><ol><li><p>性能极高: Redis能读的速度是1100000次/秒, 写的速度是81000次/秒。</p></li><li><p>丰富的数据类型: Redis支持Lists、Hashes、Sets、Sorted Sets等数据类型操作。</p></li><li><p>原子操作: Redis的所有操作都是原子性的, 同时Redis还支持对几个操作合并后的原子性执行(事务)。</p></li><li><p>丰富的特性: Redis还支持publish/subscribe、通知、key过期等特性。</p></li><li><p>高并发原理:</p><ol><li>Redis是纯内存数据库, 所以读取速度快。</li><li>Redis使用的是非阻塞IO, IO多路复用, 减少了线程切换时上下文的切换和竞争。</li><li>Redis采用了单线程的模型, 保证了每个操作的原子性, 也减少了线程的上下文切换和竞争。</li><li>Redis存储结构多样化, 不同的数据结构对数据存储进行了优化加快读取的速度。</li><li>Redis采用自己实现的事件分离器, 效率比较高, 内部采用非阻塞的执行方式, 吞吐能力比较大。</li></ol></li></ol><h3 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h3><ol><li>Redis、Memcached、Ehcache的区别</li></ol><h3 id="哨兵模式" tabindex="-1">哨兵模式 <a class="header-anchor" href="#哨兵模式" aria-label="Permalink to &quot;哨兵模式&quot;">​</a></h3><ol><li>多节点条件下, master节点负责写, slave节点负责读。</li></ol><h2 id="基本数据类型" tabindex="-1">基本数据类型 <a class="header-anchor" href="#基本数据类型" aria-label="Permalink to &quot;基本数据类型&quot;">​</a></h2><h3 id="字符串-strings" tabindex="-1">字符串(strings) <a class="header-anchor" href="#字符串-strings" aria-label="Permalink to &quot;字符串(strings)&quot;">​</a></h3><p>字符串是Redis最简单的储存类型, 他存储的值可以是字符串, 整数或者浮点数, 对整个字符串或者字符串的其中一部分执行操作；对整数或者浮点数执行自增(increment)或者自减(decrement)操作。</p><p>Redis的字符串是一个由字节组成的序列, 跟Java中的ArrayList有些类似, 采用预分配冗余空间的方式来减少内存的频繁分配, 内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时, 扩容都是加倍现有的空间, 如果超过1M, 扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p><h4 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h4><p>字符串类型在工作中使用广泛, 主要用于缓存数据, 提高查询性能。比如存储登录用户信息、电商中存储商品信息、可以做计数器(想知道什么时候封锁一个IP地址(访问超过几次))等等。</p><h4 id="指令操作" tabindex="-1">指令操作 <a class="header-anchor" href="#指令操作" aria-label="Permalink to &quot;指令操作&quot;">​</a></h4><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">set</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> key value: 添加一条String数据类型</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> key: 获取一条String类型数据</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mset</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> key1 value1 key2 value2: 添加多条String数据类型</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mget</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> key1 key2: 获取多条String类型数据</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">incr</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> key: 自增</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">+1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">incrby</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> key step: 按照步长</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">step</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">自增</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">decr</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> key: 自减</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">-1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">decrby</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> key step: 按照步长</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">step</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">递减</span></span></code></pre></div><h3 id="散列-hashes" tabindex="-1">散列(hashes) <a class="header-anchor" href="#散列-hashes" aria-label="Permalink to &quot;散列(hashes)&quot;">​</a></h3><p>散列相当于Java中的HashMap, 内部是无序字典。实现原理和HashMap一致。一个哈希表由多个节点, 每个节点保存一个键值对。</p><p>与Java中的HashMap不同的是, rehash的方式不一样, 因为Java的HashMap在字典很大时, rehash是个耗时的操作, 需要一次性全部rehash。Redis未了高性能, 不能堵塞服务, 所以采用了渐进式rehash策略。</p><p>渐进式rehash会在rehash的同时, 保留新旧两个hash结构, 查询时会同时查询两个hash结构, 然后在后续的定时任务中以及hash操作指令中, 循序渐进地将旧hash的内容一点点迁移到新的hash结构中。当搬迁完成了, 就会使用新的hash结构取而代之。</p><p>当hash移除了醉后一个元素之后, 该数据结构自动被删除, 内存被回收。</p><h4 id="应用场景-1" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景-1" aria-label="Permalink to &quot;应用场景&quot;">​</a></h4><p>Hash也可以同于对象存储, 比如存储用户信息, 与字符串不一样的是, 字符串是需要将对象进行序列化(比如json序列化)之后才能保存, 而Hash则可以将用户对象的每个字段单独存储, 这样就能节省序列化和反序列化的时间。如下: 此外还可以保存用户的购买记录, 比如key为用户id, field为商品id, value为商品数量。同样还可以用于购物车数据的存储, 比如key为用户id, field为商品id, value为购买数量等等。</p><h4 id="指令操作-1" tabindex="-1">指令操作 <a class="header-anchor" href="#指令操作-1" aria-label="Permalink to &quot;指令操作&quot;">​</a></h4><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 添加某个属性值</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hset</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> keyname field1 value1 field2 value2</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 获取某个属性值</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hget</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> keyname field</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 获取多个属性值</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hmget</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> keyname field</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 获取所有属性值</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hgetall</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> keyname</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 获取属性数量</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hlen</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> keyname</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 自增</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hincrby</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> keyname field step</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 删除(通用)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">del</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> keyname</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 删除(hash用)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hdel</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> keyname</span></span></code></pre></div><h3 id="列表-lists" tabindex="-1">列表(lists) <a class="header-anchor" href="#列表-lists" aria-label="Permalink to &quot;列表(lists)&quot;">​</a></h3><p>Redis中的lists相当于Java中的LinkedList, 实现原理是一个双向链表(其底层是一个快速列表), 即可以支持反向查找和遍历, 更方便操作。插入和删除操作非常快, 时间复杂度为O(1), 但是索引定位很慢, 时间复杂度为O(n)。</p><h4 id="应用场景-2" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景-2" aria-label="Permalink to &quot;应用场景&quot;">​</a></h4><p>lists的应用场景非常多, 可以利用它轻松实现热销榜；可以实现工作队列(利用lists的push操作, 将任务存在lists中, 然后工作线程再用pop操作将任务取出进行执行)；可以实现最新列表, 比如最新评论等。</p><h4 id="指令操作-2" tabindex="-1">指令操作 <a class="header-anchor" href="#指令操作-2" aria-label="Permalink to &quot;指令操作&quot;">​</a></h4><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 左进</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lpush</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> key value1 value2 value3...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 左出</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lpop</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> key</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 右进</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rpush</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> key value1 value2 value3...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 右出</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rpop</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> key</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 搜索</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lrange</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> student </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span></code></pre></div><h3 id="集合-sets" tabindex="-1">集合(sets) <a class="header-anchor" href="#集合-sets" aria-label="Permalink to &quot;集合(sets)&quot;">​</a></h3><p>集合类似Java中的HashSet, 内部实现是一个value永远为null的HashMap, 实际就是通过计算hash的方式类快速重排的, 这也是set能提供判断一个成员是否能在集合内的原因。</p><h4 id="用户场景" tabindex="-1">用户场景 <a class="header-anchor" href="#用户场景" aria-label="Permalink to &quot;用户场景&quot;">​</a></h4><p>Redis的sets类型是使用哈希表构造的, 因此复杂度是O(1), 它支持集合内的增删改查, 并且支持多个集合间的交集、并集、差集操作。可以利用这些集合操作, 解决程序开发过程当中很多数据集合间的问题。比如计算网络独立ip, 用户画像中的用户标签, 共同好友等功能。</p><h4 id="指令操作-3" tabindex="-1">指令操作 <a class="header-anchor" href="#指令操作-3" aria-label="Permalink to &quot;指令操作&quot;">​</a></h4><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 添加内容</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sadd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> key value1 value2</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 查询key里所有的值</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">smembers</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> key</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 移除key里面的某个value</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">srem</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> key value</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 随机移除某个value</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spop</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> key</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 返回两个set的并集</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sunion</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> key1 key2</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 返回key1踢出交集的那部分(差集)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sdiff</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> key1 key2</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 与siffer相反, 返回交集</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sinter</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> key1 key2</span></span></code></pre></div><h3 id="有序集合-sorted-sets" tabindex="-1">有序集合(sorted sets) <a class="header-anchor" href="#有序集合-sorted-sets" aria-label="Permalink to &quot;有序集合(sorted sets)&quot;">​</a></h3><p>sorted sets是Redis类似于SortedSet和HashMap的结合体, 一方面它是一个set, 保证了内部value的唯一性, 另一方面它可以给每个value赋予一个score, 代表这个value的排序权重。内部使用HashMap和跳越表(SkipList)来保证数据的存储和有序, HashMap里放的是成员到score的映射, 而跳越表里存放的是所有的成员, 排序依据是HashMap里存的score, 使用跳越表的结构可以获得比较高的查找效率, 并且在实现上比较简单。sorted sets中最后一个value被移除后, 数据结构自动删除, 内存被回收。</p><h4 id="跳越列表-skiplist" tabindex="-1">跳越列表(SkipList) <a class="header-anchor" href="#跳越列表-skiplist" aria-label="Permalink to &quot;跳越列表(SkipList)&quot;">​</a></h4><p>sorted sets内部的排序功能是通过「跳越列表」数据结构来实现的, 它的结构非常特殊也比较复杂。因为zset要支持随机的插入和删除, 所以它不好使用数组来表示。</p><p>这就要用到跳越列表, 在本质上跳越列表就是通过一套随机升级的方法, 实现多级链表(缓存), 再通过这样的缓存一级一级向下搜索。具体过程描述为, 当在跳越表中查找一个元素x:</p><ol><li>从最上层的链(Ln)的开头开始。</li><li>假设当前位置为p, 它向右指向的节点为q(p与q不一定相邻), 且q的值为y。 将y与x作比较: <ol><li>x=y 输出查询成功</li><li>x&gt;y 从p向右移动到q的位置</li><li>x&lt;y 从p向下移动一格</li></ol></li><li>如果当前位置在最底层的链中(L0), 且还要向下移动的话, 则输出查询失败</li></ol><h4 id="应用场景-3" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景-3" aria-label="Permalink to &quot;应用场景&quot;">​</a></h4><p>主要应用于根据某个权重进行排序的队列的场景, 比如游戏积分排行榜, 设置优先级的任务列表, 学生成绩等。</p><h4 id="指令操作-4" tabindex="-1">指令操作 <a class="header-anchor" href="#指令操作-4" aria-label="Permalink to &quot;指令操作&quot;">​</a></h4><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 添加元素</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">zadd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> key score value [score value...]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 获取集合的值并按照score从小到大排列, 最小的是最上面</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">zrange</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> key start end</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 返回有序集key中, 所有score值介于min和max之间(闭区间)的成员。有序集成员按score值递增次序排列</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">zrangebyscore</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> key scorestart scoreend</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 删除</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">zrem</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> key value</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 统计元素</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">zcard</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> rank</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 按照score大小统计</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">zcount</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> rank scorestart scoreend</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 获取位置</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">zrank</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> key value</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 获取反转位置</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">zrevrank</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> key value</span></span></code></pre></div>`,49),h=[l];function t(p,k,r,d,c,o){return i(),a("div",null,h)}const g=s(n,[["render",t]]);export{y as __pageData,g as default};
